using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GenerateMaze : MonoBehaviour
{
    [SerializeField]
    GameObject roomPrefab;
    public GameObject door;
    public GameObject keyPrefab; // Key Prefab
    public int totalKeysRequired = 3; // Number of keys required to open the door

    private int keysCollected = 0;
    Room[,] rooms = null;

    [SerializeField]
    int numX = 10;
    [SerializeField]
    int numY = 10;

    float roomWidth;
    float roomHeight;

    Stack<Room> stack = new Stack<Room>();
    bool generating = false;
    private GameObject spawnedDoor;

    private void GetRoomSize()
    {
        SpriteRenderer[] spriteRenderers = roomPrefab.GetComponentsInChildren<SpriteRenderer>();

        Vector3 minBounds = Vector3.positiveInfinity;
        Vector3 maxBounds = Vector3.negativeInfinity;

        foreach(SpriteRenderer ren in spriteRenderers)
        {
            minBounds = Vector3.Min(minBounds, ren.bounds.min);
            maxBounds = Vector3.Max(maxBounds, ren.bounds.max);
        }

        roomWidth = maxBounds.x - minBounds.x;
        roomHeight = maxBounds.y - minBounds.y;
    }

    private void SetCamera()
    {
        Camera.main.transform.position = new Vector3(numX * (roomWidth - 1) / 2, numY * (roomHeight - 1) / 2, -100.0f);
        float min_value = Mathf.Min(numX * (roomWidth - 1), numY * (roomHeight - 1));
        Camera.main.orthographicSize = min_value * 0.75f;
    }

    private void Start()
    {
        GetRoomSize();
        rooms = new Room[numX, numY];

        for(int i = 0; i < numX; ++i)
        {
            for (int j = 0; j < numY; ++j)
            {
                GameObject room = Instantiate(roomPrefab, new Vector3(i * roomWidth, j * roomHeight, 0.0f), Quaternion.identity);
                room.name = "Room_" + i.ToString() + "_ " + j.ToString();
                rooms[i, j] = room.GetComponent<Room>();
                rooms[i, j].Index = new Vector2Int(i, j);
            }
        }

        SetCamera();
    }

    private void RemoveRoomWall(int x, int y, Room.Directions dir)
    {
        if(dir != Room.Directions.NONE)
        {
            rooms[x, y].SetDirFlag(dir, false);
        }

        Room.Directions opp = Room.Directions.NONE;
        switch (dir)
        {
            case Room.Directions.TOP:
                if(y < numY - 1) { opp = Room.Directions.BOTTOM; ++y; }
                break;
            case Room.Directions.RIGHT:
                if(x < numX - 1) { opp = Room.Directions.LEFT; ++x; }
                break;
            case Room.Directions.BOTTOM:
                if(y > 0) { opp = Room.Directions.TOP; --y; }
                break;
            case Room.Directions.LEFT:
                if(x > 0) { opp = Room.Directions.RIGHT; --x; }
                break;
        }
        if(opp != Room.Directions.NONE)
        {
            rooms[x, y].SetDirFlag(opp, false);
        }
    }

    public void CreateMaze()
    {
        if(generating) return;

        Reset();
        RemoveRoomWall(0, 0, Room.Directions.BOTTOM);
        RemoveRoomWall(numX - 1, numY - 1, Room.Directions.RIGHT);

        Vector3 doorPosition = rooms[numX - 1, numY - 1].transform.position;
        doorPosition.x += (roomWidth - 1)/ 2;
        spawnedDoor = Instantiate(door, doorPosition, Quaternion.identity);
        spawnedDoor.SetActive(false); // Initially hide the door

        SpawnKeys();
        stack.Push(rooms[0, 0]);
        StartCoroutine(Coroutine_Generate());
    }

    private void SpawnKeys()
    {
        HashSet<Vector2Int> usedPositions = new HashSet<Vector2Int>();
        for(int i = 0; i < totalKeysRequired; i++)
        {
            int x, y;
            do
            {
                x = UnityEngine.Random.Range(0, numX);
                y = UnityEngine.Random.Range(0, numY);
            }
            while(usedPositions.Contains(new Vector2Int(x, y)) || (x == 0 && y == 0)); // Avoid start position

            usedPositions.Add(new Vector2Int(x, y));
            Vector3 keyPosition = rooms[x, y].transform.position;
            Instantiate(keyPrefab, keyPosition, Quaternion.identity);
        }
    }

    public void CollectKey()
    {
        keysCollected++;
        if (keysCollected >= totalKeysRequired && spawnedDoor != null)
        {
            spawnedDoor.SetActive(true); // Open the door
        }
    }

    IEnumerator Coroutine_Generate()
    {
        generating = true;
        bool flag = false;
        while(!flag)
        {
            flag = GenerateStep();
            yield return null;
        }
        generating = false;
    }

    private void Reset()
    {
        keysCollected = 0;
        for(int i = 0; i < numX; ++i)
        {
            for (int j = 0; j < numY; ++j)
            {
                rooms[i, j].SetDirFlag(Room.Directions.TOP, true);
                rooms[i, j].SetDirFlag(Room.Directions.RIGHT, true);
                rooms[i, j].SetDirFlag(Room.Directions.BOTTOM, true);
                rooms[i, j].SetDirFlag(Room.Directions.LEFT, true);
                rooms[i, j].visited = false;
            }
        }
    }

    private void Update()
    {
        if(Input.GetKeyDown(KeyCode.Space) && !generating)
        {
            CreateMaze();
        }
    }
}
